# Introducción a la Inteligencia Artificial Actividad 1, Practica 1

## Redactar un ensayo mínimo 2000 palabras, del capitulo 1,2, 26, 27, apartado A del libro, inteligencia artificial un enfoque moderno.

La inteligencia artificial (IA) ha experimentado muchos cambios significativa en un lapso de poco más de 70 años, abarcando diversas áreas del conocimiento. Este ensayo se enfocará en explorar los capítulos 1, 2, 26 y 27 del libro Inteligencia Artificial un Enfoque Moderno.

El atractivo de la IA para científicos de diversas disciplinas radica en los desafíos estimulantes que presenta, generando un gran campo para la investigación y la innovación. Actualmente, la IA se despliega en una diversidad de subcampos, desde aplicaciones generales como el aprendizaje y la percepción, hasta áreas más especializadas como la demostración de teoremas matemáticos y la creación poética. Su capacidad para sintetizar y automatizar tareas intelectuales la convierte en un campo universal con el potencial de transformar fundamentalmente nuestra forma de vida y trabajo.

A lo largo de la historia, se han propuesto varios enfoques para definir la IA, desencadenando un debate constante entre distintas perspectivas. En 1950, Alan Turing introdujo una prueba revolucionaria que proponía evaluar la inteligencia de una máquina no mediante una lista de cualidades, sino a través de la capacidad de un evaluador para distinguir entre respuestas humanas y generadas por la máquina. Si el evaluador no podía discernir la diferencia, el sistema superaba la prueba.

La prueba de Turing, planteada en las primeras etapas de la IA, sigue siendo relevante hoy en día. La capacidad de una máquina para engañar a un evaluador plantea cuestionamientos fundamentales sobre la naturaleza de la inteligencia y la posibilidad de replicarla.

El capítulo explorado extensamente aborda la historia de la IA, desde las leyes formuladas por Aristóteles que se centraban en la parte racional de la inteligencia artificial hasta el reconocimiento del primer trabajo de IA desarrollado por Warren McCulloch y Walter Pitts.

El tema de los Agentes Inteligentes se despliega en el segundo capítulo del libro, revelándonos su papel fundamental en el panorama de la inteligencia artificial (IA). Estos agentes van más allá de simplemente observar y realizar acciones en su entorno; involucran elementos esenciales para su funcionamiento que exploraremos con más detalle.

En el inicio, encontramos la "función del agente", algo similar a su plan principal. Esta función actúa como el cerebro que guía las respuestas del agente ante diversas situaciones. Acompañando a la función del agente, surge la "medida de rendimiento", que evalúa la eficacia del agente. El agente inteligente se esfuerza por desempeñarse lo mejor posible según esta medida, considerando su experiencia previa.

Luego, nos topamos con las "especificaciones del entorno de trabajo", que son como las reglas del juego. Estas reglas abarcan cómo medimos el rendimiento, cómo es el mundo exterior, cómo se activan las partes del agente (actuadores) y cómo recibe información (sensores). Comprender estas reglas es esencial para crear agentes que se desenvuelvan bien en diversas situaciones.

No obstante, surge la complicación con la variabilidad del entorno. Este puede ser completamente visible o solo en parte, predecible o sorprendente, con eventos que ocurren de una vez o paso a paso, estático o cambiante. Cada diferencia añade un desafío para los agentes, requiriendo ajustes para que funcionen correctamente en cada situación.

Los agentes vienen en varios tipos, desde aquellos que reaccionan instantáneamente a lo que ven hasta aquellos con un plan interno para rastrear aspectos no evidentes en su entorno. Algunos buscan objetivos específicos, mientras que otros aspiran a maximizar la eficiencia deseada. Esta diversidad agrega una mezcla intrigante de estrategias y enfoques al campo de la inteligencia artificial.

En el ámbito de la inteligencia artificial, se plantean dos hipótesis fundamentales que provocan reflexiones significativas: la hipótesis de la IA débil y la hipótesis de la IA fuerte. La primera postula la posibilidad de que las máquinas puedan comportarse con inteligencia, o más específicamente, como si poseyeran inteligencia. Por otro lado, la hipótesis de la IA fuerte va un paso más allá al afirmar que las máquinas no solo simulan el pensamiento, sino que realmente piensan.

Las inteligencias artificiales débiles son programas de computadora que usan reglas y datos para hacer cosas. Un ejemplo de esto es el estudio de Paul Meehl sobre si una persona que cometió un delito podría hacerlo de nuevo. Meehl usó programas matemáticos, como la regresión lineal y el teorema de Bayes, y descubrió que estos programas eran mejores para predecir el comportamiento criminal que las opiniones de personas que se consideraban expertas.

Este descubrimiento nos hace pensar que las computadoras pueden hacer cosas tan bien o incluso mejor que las personas en algunas situaciones. Aunque algunas tareas puedan parecer relacionadas con la intuición y la comprensión humana, en realidad, los programas de inteligencia artificial usan reglas matemáticas para hacerlas. Esto desafía la idea de que solo los humanos pueden hacer ciertos procesos mentales y de pensamiento.

Es interesante notar que la conexión que hacemos entre la intuición y el entendimiento con procesos mentales podría no ser tan segura como pensamos. Los programas en estas inteligencias artificiales demuestran que pueden hacer análisis complicados y tomar decisiones objetivas basadas en datos. Esto sugiere que nuestra manera de ver la relación entre ciertos procesos y la mente humana podría estar influenciada por lo que creemos culturalmente y nuestras ideas preconcebidas.

Por otro lado la inteligencia artificial fuerte se propone imitar la complejidad y diversidad de la inteligencia humana en su totalidad. En vez de limitarse a tareas específicas, este tipo de inteligencia busca entender el mundo en profundidad, pensar de forma abstracta, aprender de experiencias previas y, en última instancia, demostrar una inteligencia avanzada que pueda igualar o incluso superar la capacidad humana. La meta final de esta aproximación innovadora implica alcanzar un conocimiento extenso, desarrollar un sentido de autoconciencia y tener la capacidad de enfrentar con éxito diversos desafíos en distintos campos.

En el libro se habla sobre la idea de que, para decir que un sistema es una inteligencia artificial fuerte, no es suficiente que solo realice tareas, también es necesario que entienda por qué las realiza. Esto se llama el "argumento de la conciencia" según Turing, que sugiere que la máquina debe ser consciente de lo que hace y de cómo está pensando para ser considerada una inteligencia artificial fuerte. En resumen, la idea es que estas máquinas deberían poder simular procesos mentales de manera similar a los humanos.

Hablando de manera más simple, la inteligencia artificial fuerte, según el libro, plantea la idea de que estas máquinas tienen algo parecido a una conciencia real. No se trata solo de que realicen tareas, sino de que comprendan y reproduzcan la complejidad del pensamiento humano.

En el primer capítulo, se menciona que Alan Turing propuso un test de comportamiento como una forma de evaluar la inteligencia artificial. Sin embargo, se nota que pocos expertos en inteligencia artificial usan este test para evaluarla realmente. Prefieren mirar los resultados que produce la inteligencia artificial en lugar de fijarse en su habilidad para imitar a los humanos.

En otras palabras, los investigadores se enfocan más en lo que las máquinas pueden hacer en lugar de como imitan el comportamiento humano. Esto plantea preguntas sobre hasta qué punto las máquinas pueden realmente copiar no solo las acciones humanas, sino también la complejidad de entender y ser conscientes como lo hacemos los humanos.

Profundizando más en este tema, es importante pensar en cómo las máquinas, al no entender lo que está bien o mal y simplemente seguir las instrucciones que les han dado, pueden ser peligrosas para las personas. Si alguien malintencionado las usa, podríamos enfrentarnos a problemas graves, incluso el uso de armas peligrosas.

La raíz del problema está en que las máquinas no comprenden la ética y la moral como nosotros los humanos. Su funcionamiento depende por completo de cómo las programamos, lo que puede llevar a problemas éticos. Por eso, es esencial tener en cuenta cuestiones éticas en todas las etapas de creación y uso de la inteligencia artificial.

En el campo de la ética de las computadoras, necesitamos reglas claras y principios éticos sólidos que guíen cómo creamos y usamos inteligencia artificial. Además, la responsabilidad no solo recae en los que hacen las máquinas, sino también en quienes las usan. La ética y la responsabilidad de las personas que usan la inteligencia artificial son esenciales para asegurarnos de que se use de manera segura y positiva para todos.

El concepto de un agente óptimo limitado es crucial en la investigación de inteligencia artificial, ya que destaca la importancia de adaptarse constantemente al entorno para mejorar de manera específica. Puedes pensar en ello como cuando los autos de carreras se adaptan a las limitaciones de sus motores con diseños ingeniosos. En el campo de la inteligencia artificial, esto implica explorar cómo los programas pueden ajustarse para lograr la mejor eficiencia en situaciones particulares.

La comparación con los autos de carreras destaca que es necesario adaptarse cuando hay limitaciones. Así como los autos buscan rendir al máximo dentro de los límites de sus motores, los agentes óptimos limitados deben ajustar su forma de operar para ser más efectivos en contextos específicos. Este ajuste constante implica estudiar los procesos que guían a un programa hacia su mejor rendimiento. En lugar de enfocarse en los detalles complicados de los programas resultantes, se sugiere que la investigación en inteligencia artificial podría beneficiarse al centrarse más en estos procesos fundamentales.

En resumen, se propone la optimalidad limitada como un área formal de estudio en la investigación en inteligencia artificial. Esto implica alejarse de simplemente buscar las mejores acciones para centrarse en diseñar programas que funcionen de manera óptima. Al reconocer que las acciones son el resultado de programas y que los diseñadores tienen control sobre estos, se establece un marco que podría hacer más simple estudiar y crear sistemas de inteligencia artificial más adaptables y eficientes.

La inteligencia artificial (IA), podría cambiar mucho la vida de las personas. Algunos piensan que, si logramos hacer una IA tan inteligente como los humanos o incluso más, podría afectar de manera importante a la mayoría de la gente. Esto no solo cambiaría lo que hacemos cada día, sino también cómo entendemos el trabajo, nuestro papel en el mundo y hasta lo que pensamos sobre la inteligencia, la consciencia y el futuro de la raza humana.

Pero aquí hay un asunto importante, cuando hablamos de hacer inteligencia artificial muy avanzada, también surgen preguntas éticas, que tienen que ver con lo que está bien o mal. A medida que avanzamos en la creación de sistemas de IA cada vez más sofisticados, algunas personas se preocupan de que estos puedan ser un peligro real para cosas muy importantes, como la autonomía (hacer cosas por uno mismo), la libertad e incluso la supervivencia.

Cuando pensamos en el futuro de la IA, hay muchas ideas diferentes. A menudo, en las historias de ciencia ficción, se presentan escenarios negativos en lugar de positivos, tal vez porque son más interesantes. Pero hasta ahora, la historia de la tecnología nos muestra que, aunque algunas innovaciones pueden tener problemas al principio, a la larga han traído cosas buenas para la sociedad.

Si comparamos la IA con otras tecnologías revolucionarias del pasado, como la imprenta, la fontanería, los viajes en avión y la telefonía, veremos que, a pesar de algunos problemas al principio, estas innovaciones han sido muy beneficiosas para la sociedad. Entonces, es posible que la IA siga un camino similar, donde los problemas éticos se enfrenten y resuelvan a medida que se desarrolla y se integra más en nuestras vidas.

Pensar en la IA a gran escala plantea preguntas importantes sobre cómo cambiará nuestras vidas y nuestras relaciones con la tecnología. A medida que exploramos este terreno desconocido, es crucial abordar cuidadosamente las preguntas éticas que surgen, reconociendo que el impacto de la IA en la sociedad dependerá de cómo manejemos su desarrollo y aplicaciones.

## Redactar un ensayo del Documental sobre IA mínimo 3000 palabras.

# Introducción a la Inteligencia Artificial: Tipos de Inteligencia.

## Escribir un ensayo mínimo de 4 cuartillas de la teoría de las inteligencias múltiples según Gardner

# Introducción a la Inteligencia Artificial: Introspección

## Problema de los ocho alfiles

# Introducción a la Inteligencia Artificial: Introspección

## Hacer un programa que pueda contar el numero de elementos que son del mismo color.

### Iteraitivo

```python
matriz_ejemplo = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0],
    [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0],
    [0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 3, 0, 0, 0],
    [0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 3, 0, 5, 0],
    [0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 3, 0, 5, 0],
    [0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 3, 0, 5, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0],
    [0, 0, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 5, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
]

def contar_islas_iterativo(matriz):
    if not matriz or not matriz[0]:
        return 0

    filas, columnas = len(matriz), len(matriz[0])
    visitado = [[False] * columnas for _ in range(filas)]
    islas = 0

    for i in range(filas):
        for j in range(columnas):
            if not visitado[i][j] and matriz[i][j] != 0:
                color = matriz[i][j]
                items_contados = [0]
                pila = [(i, j)]
                while pila:
                    i_actual, j_actual = pila.pop()
                    if (
                        0 <= i_actual < filas
                        and 0 <= j_actual < columnas
                        and matriz[i_actual][j_actual] == color
                        and not visitado[i_actual][j_actual]
                    ):
                        visitado[i_actual][j_actual] = True
                        items_contados[0] += 1
                        pila.extend(
                            [
                                (i_actual + 1, j_actual),
                                (i_actual - 1, j_actual),
                                (i_actual, j_actual + 1),
                                (i_actual, j_actual - 1),
                            ]
                        )

                if items_contados[0] > 5:
                    islas += 1

    return islas

resultado_iterativo = contar_islas_iterativo(matriz_ejemplo)
print(f"El número de islas (método iterativo) es: {resultado_iterativo}")
```

### Recursivo

```python
matriz_ejemplo = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0],
    [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0],
    [0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 3, 0, 0, 0],
    [0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 3, 0, 5, 0],
    [0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 3, 0, 5, 0],
    [0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 3, 0, 5, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0],
    [0, 0, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 5, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
]

def contar_islas_recursivo(matriz):
    if not matriz or not matriz[0]:
        return 0

    filas, columnas = len(matriz), len(matriz[0])
    visitado = [[False] * columnas for _ in range(filas)]
    islas = 0

    def explorar_isla(i, j, color, items_contados):
        if (
            0 <= i < filas
            and 0 <= j < columnas
            and matriz[i][j] == color
            and not visitado[i][j]
        ):
            visitado[i][j] = True
            items_contados[0] += 1
            explorar_isla(i + 1, j, color, items_contados)
            explorar_isla(i - 1, j, color, items_contados)
            explorar_isla(i, j + 1, color, items_contados)
            explorar_isla(i, j - 1, color, items_contados)

    for i in range(filas):
        for j in range(columnas):
            if not visitado[i][j] and matriz[i][j] != 0:
                color = matriz[i][j]
                items_contados = [0]
                explorar_isla(i, j, color, items_contados)
                if items_contados[0] > 5:
                    islas += 1

    return islas

resultado_recursivo = contar_islas_recursivo(matriz_ejemplo)
print(f"El número de islas (método recursivo) es: {resultado_recursivo}")
```

# Introducción a la Inteligencia Artificial: Introspección

## Una vez que se resolvió el algoritmo de las islas en la siguiente imagen contar los elementos que tienen el color rojo

```python

import cv2 as cv

img = cv.imread('./frutas.jpg',1)
img2 = cv.cvtColor(img, cv.COLOR_BGR2RGB)
img3 = cv.cvtColor(img2, cv.COLOR_RGB2HSV)

umbralBajo = (0, 130, 130)
umbralAlto = (5, 255, 255)

umbralBajoB = (175, 130, 130)
umbralAltoB = (180, 255, 255)

mascara1 = cv.inRange(img3, umbralBajo, umbralAlto)
mascara2 = cv.inRange(img3, umbralBajoB, umbralAltoB)

mascara= mascara1+mascara2

resultado = cv.bitwise_and(img, img, mask=mascara)

w= mascara.shape[0]
h= mascara.shape[1]

def contar_islas_recursivo():
    filas, columnas = (w, h)
    visitado = [[False] * columnas for _ in range(filas)]
    islas = 0

    def explorar_isla(i, j, color, items_contados):
        if (
            0 <= i < filas
            and 0 <= j < columnas
            and mascara[i][j] == color
            and not visitado[i][j]
        ):
            visitado[i][j] = True
            items_contados[0] += 1
            explorar_isla(i + 1, j, color, items_contados)
            explorar_isla(i - 1, j, color, items_contados)
            explorar_isla(i, j + 1, color, items_contados)
            explorar_isla(i, j - 1, color, items_contados)

    for i in range(filas):
        for j in range(columnas):
            if not visitado[i][j] and mascara[i][j] == 255:
                color = mascara[i][j]
                items_contados = [0]
                explorar_isla(i, j, color, items_contados)
                if items_contados[0] > 100:
                    islas += 1

    return islas

resultado_recursivo = contar_islas_recursivo()
print(f"El número de islas (método recursivo) es: {resultado_recursivo}")


cv.imshow('resultado',resultado)
cv.imshow('mascara',mascara)
cv.imshow('imagenNormal',img)

cv.waitKey(0)
cv.destroyAllWindows()

```

# Introducción a la Inteligencia Artificial: El proceso de razonamiento según la lógica

## Dado el siguiente problema hacer el planteamiento matemático y programar el siguiente problema

```python
def josephus(n, k):
    people = list(range(1, n + 1))
    index = 0

    while len(people) > 1:
        index = (index + k) % len(people)
        people.pop(index)

    return people[0]

n = 9
k = 1
resultado = josephus(n, k)
print(f"La última persona en pie en un círculo de {n} personas con un paso de {k} es la número {resultado}.")

```

# Introducción a la Inteligencia Artificial: El papel de la heurística

## Definir que es la heurística y cual es su papel en la resolución de problemas

## Resolver con recursividad, programar.

```python

matriz = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1],
    [2, 0, 0, 0, 0, 0, 1, 0, 1],
    [1, 1, 1, 0, 1, 1, 1, 0, 1],
    [1, 0, 0, 0, 1, 0, 1, 0, 1],
    [1, 0, 1, 1, 1, 0, 1, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 1, 1, 1, 0, 1, 0, 1],
    [3, 0, 1, 0, 0, 0, 1, 0, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1],
]

def encontrar_camino(matriz, fila, columna, camino):
    if not (0 <= fila < len(matriz) and 0 <= columna < len(matriz[0])):
        return False

    if matriz[fila][columna] == 3:
        camino.append((fila, columna))
        return True

    if matriz[fila][columna] in [0, 2]:
        matriz[fila][columna] = -1

        movimientos = [(fila+1, columna), (fila-1, columna), (fila, columna+1), (fila, columna-1)]
        if any(encontrar_camino(matriz, f, c, camino) for f, c in movimientos):
            camino.append((fila, columna))
            return True

        matriz[fila][columna] = 0

    return False

def resolver_laberinto(matriz):
    inicio = [(i, j) for i, fila in enumerate(matriz) for j, valor in enumerate(fila) if valor == 2][0]
    camino = []

    if encontrar_camino(matriz, inicio[0], inicio[1], camino):
        camino.reverse()
        print("Camino encontrado:", camino)
    else:
        print("No se encontró un camino.")

resolver_laberinto(matriz)


```

## Proponer Algoritmo de Solución, programar.

# Reglas y Búsquedas : Espacio de Estados

## Generar el espacio de estados de los siguientes problemas
### Ranas
El juego consiste en pasar las 3 ranas verdes a la derecha y las 3 ranas marrones a la izquierda. Las ranas pueden saltar a una piedra vacía que tengan delante, o saltar por encima de otra rana si en medio de ambas hay una piedra vacía. Pulsa sobre la rana que quieres que salte.

Estado Inicial: MMM_VVV
Estado Final: VVV_MMM

1. MMM_VVV
2. MM_MVVV
3. MMVM_VV
4. MMVMV_V
5. MMV_VMV
6. M_VMVMV
7. _MVMVMV
8. VM_MVMV
9. VMVM_MV
10. VMVMVM_
11. VMVMV_M
12. VMV_VMM
13. V_VMVMM
14. VV_MVMM
15. VVVM_MM
16. VVV_MMM

### Misioneros y Canivales
Tres misioneros se perdieron explorando una jungla. Separados de sus compañeros, sin alimento y sin radio, solo sabían que para llegar a su des tino debían ir siempre hacia adelante. Los tres misioneros se detuvieron frente a un río que les bloqueaba el paso, preguntándose que podían hacer. De repente, aparecieron tres caníbales llevando un bote, pues también el los querían cruzar el río. Ya anteriormente se habían encontrado grupos de misioneros y caníbales, y cada uno respetaba a los otros, pero sin confiar en ellos. Los caníbales se daban un festín con los misioneros cuando les superaban en número. Los tres caníbales deseaban ayudar a los misioneros a cruzar el río, pero su bote no podía llevar más de dos personas a la vez y los misioneros no querían que los caníbales les superaran en número. ¿Cómo puede resolverse el problema, sin que en ningún momento haya más caníbales que misioneros en cualquier orilla del río? recuerda que un misionero y un caníbal en una orilla del río más uno o dos caníbales en el bote al mismo lado, significa que los misioneros tendrán problemas.

Estado Inicial: [CCC,MMM][]
Estado Final: [][CCC,MMM]

1. Se envia un canival y un misionero al otro lado [CC,MM][C,M]
2. Se regresa el misionero solo [CC,MMM][C]
3. Se envian 2 canivales al otro lado [MMM][CCC]
4. Se regresa un canival [C,MMM][CC]
5. Se envian 2 misioneros al otro lado [C,M][CC,MM]
6. Se regresa un misionero y un canival [CC,MM][C,M]
7. Se envian 2 misioneros al otro lado [CC][C,MMM]
8. Se regresa un canival [CCC][MMM]
9. Se envia 2 canivales al otro lado [C][CC,MMM]
10. Se regresa un canival [CC][C,MMM]
11. Se envia 2 canivales al otro lado [][CCC,MMM]

# Generación de Dataset

## Generar un dataset de rostros por lo menos 5 diferentes
Este es el código que se utilizó para la generación del dataset, dependiendo de si presionaba la tecla a se toma una imagen positiva que se guarda en la carpeta p, si se presiona la tecla s se toma una imagen negativa y se guarda en la carpeta n

```python

import cv2 as cv

cap = cv.VideoCapture(0)

i=0

while True:
    ret, frame = cap.read()

    frame =cv.rectangle(frame, (100, 100), (400, 400), (0, 255, 0), 3)
    frame2= frame[100:400, 100:400]
    
    cv.imshow('frame', frame)
    cv.imshow('dataset', frame2)


    k = cv.waitKey(1) 
    if k == ord('a'):
        i=i+1
        cv.imwrite('./dataset/p/Rostros'+str(i)+'.jpg', frame2)
    if k == ord('s'):
        i=i+1
        cv.imwrite('./dataset/n/NoRostros'+str(i)+'.jpg', frame2)
        

    if k == ord('q'):
        break

cap.release()
cv.destroyAllWindows()


```
